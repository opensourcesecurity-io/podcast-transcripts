0
00:00:05,289 --> 00:00:09,409
Hello and welcome to the open source security podcast with myself, Kurt Siefried

1
00:00:09,760 --> 00:00:12,710
and my partner in disparaging technology. Josh Pressers,

2
00:00:13,310 --> 00:00:16,700
we disparage all technology. That's not a surprise.

3
00:00:17,250 --> 00:00:18,950
Well, some more than others.

4
00:00:19,260 --> 00:00:21,690
Like I think rocks are pretty good. I like rocks.

5
00:00:21,989 --> 00:00:22,989
Rocks are dependable.

6
00:00:23,399 --> 00:00:25,200
I'm not so sure about this bronze age thing.

7
00:00:25,989 --> 00:00:29,969
Oh, I know. I know. Seriously. What was up with that coming out of the trees?

8
00:00:29,979 --> 00:00:32,930
What was, didn't Douglas Adams have a joke about that with digital watches?

9
00:00:33,169 --> 00:00:34,810
Yeah. Coming down from the trees.

10
00:00:35,220 --> 00:00:36,209
Is it all went wrong

11
00:00:36,580 --> 00:00:37,770
anyway? Anyway.

12
00:00:37,959 --> 00:00:40,169
And then something about digital watches was included,

13
00:00:40,180 --> 00:00:42,490
which I love how much he picks on digital watches.

14
00:00:42,680 --> 00:00:43,529
He's not wrong.

15
00:00:43,540 --> 00:00:45,270
One thing I love is when I go to the pool with my kids,

16
00:00:45,279 --> 00:00:46,970
I go to the little toddler pool that just soak

17
00:00:46,979 --> 00:00:48,750
in the hot water and splash around and have fun.

18
00:00:48,830 --> 00:00:52,130
And I'm always reminded of like this is what being a sea otter must be like,

19
00:00:53,500 --> 00:00:54,830
you know, like just, oh,

20
00:00:55,009 --> 00:00:57,490
like when I see those videos of sea otters,

21
00:00:57,840 --> 00:01:01,259
they just look so like relaxed and happy, you know, they got their little moss,

22
00:01:01,270 --> 00:01:02,259
they got their favorite little rock.

23
00:01:02,270 --> 00:01:03,009
They're smashing the moos

24
00:01:03,180 --> 00:01:05,230
cope and they're eating it. They're feeding it to their young,

25
00:01:05,519 --> 00:01:06,709
they're rafting together.

26
00:01:06,720 --> 00:01:09,069
You know, they make those little rafts where they hook to each other.

27
00:01:09,089 --> 00:01:11,959
-- Yeah,
-- that's because they don't have, they don't have internet.

28
00:01:11,970 --> 00:01:14,599
That, that's why, that's where we went wrong anyway.

29
00:01:15,220 --> 00:01:16,559
Yeah, we're going to talk about

30
00:01:16,870 --> 00:01:18,169
c, I guess today.

31
00:01:18,230 --> 00:01:21,559
Well, no, we're going to talk about memory, safe and memory, unsafe languages,

32
00:01:21,569 --> 00:01:23,599
which means we're going to throw C under the bus because

33
00:01:24,800 --> 00:01:28,480
we've been doing that for a decade now, I think.

34
00:01:28,489 --> 00:01:32,440
But ok, so I'll, I'll set the stage for us here. The,

35
00:01:32,870 --> 00:01:35,160
the NSA in the United States,

36
00:01:35,169 --> 00:01:39,940
the National Security Agency released a document talking about memory safety.

37
00:01:39,949 --> 00:01:44,279
They basically say stop using CN C++. That's like the TLDR. And

38
00:01:44,680 --> 00:01:46,940
I thought this would be worth covering

39
00:01:47,089 --> 00:01:49,339
because I know we've talked about most of this

40
00:01:49,349 --> 00:01:51,559
stuff in the past at some point which we,

41
00:01:51,569 --> 00:01:55,029
I mean, at this point, I love that we have what, like 300 some odd shows.

42
00:01:55,040 --> 00:01:58,819
Like we've talked about most everything somewhere in that back catalog

43
00:01:58,830 --> 00:02:01,330
don't go too far back because the quality is terrible.

44
00:02:01,349 --> 00:02:01,830
But

45
00:02:02,430 --> 00:02:02,940
I feel like

46
00:02:03,180 --> 00:02:03,330
one hour

47
00:02:03,459 --> 00:02:05,430
-- shows in the beginning. Oh my.
-- Oh man.

48
00:02:05,750 --> 00:02:05,870
Yes.

49
00:02:06,430 --> 00:02:06,860
Yes, we

50
00:02:07,360 --> 00:02:07,769
don't.

51
00:02:07,910 --> 00:02:12,619
And uh I, I, for some reason listened to episode one at some point, part of it for I was,

52
00:02:12,630 --> 00:02:13,860
I was doing something and I'm like,

53
00:02:14,179 --> 00:02:18,169
it's so bad. It's just terrible but whatever, it doesn't matter. OK,

54
00:02:18,429 --> 00:02:21,470
I wanted to talk about this document partially because it, it's current.

55
00:02:21,479 --> 00:02:23,559
So obviously that's interesting. But it also,

56
00:02:23,759 --> 00:02:27,460
there's some things in this that I think are worth discussing

57
00:02:27,600 --> 00:02:30,220
because not everyone knows it. Some people forget it.

58
00:02:30,229 --> 00:02:32,880
And I think it's just fun to talk about because I love C,

59
00:02:32,889 --> 00:02:34,389
I'm gonna just start with that C is

60
00:02:34,399 --> 00:02:36,800
my favorite programming language in the whole world.

61
00:02:36,809 --> 00:02:38,160
But I recognize

62
00:02:38,300 --> 00:02:39,479
it is bad.

63
00:02:40,339 --> 00:02:42,149
Like I know it's,

64
00:02:42,279 --> 00:02:46,050
it, it, it pains me to say. And I also recognize

65
00:02:46,199 --> 00:02:49,009
that even though I love C and even though I've been

66
00:02:49,020 --> 00:02:54,970
doing memory management for like literally 30 years at this point,

67
00:02:55,380 --> 00:03:00,250
I know I can't do it right. And anyone who says they can is lying.

68
00:03:00,440 --> 00:03:04,809
Yeah. Like I remember reading the cow book back in what 98 or something and realizing

69
00:03:05,210 --> 00:03:06,750
this is not for me, like I just,

70
00:03:06,759 --> 00:03:10,199
I'm going to use Pearl and Bash and Python and I'm never going

71
00:03:10,210 --> 00:03:12,229
to program and see because I just don't want to do this.

72
00:03:12,279 --> 00:03:16,020
-- There was no Python back then.
-- Oh, it's true. Yeah. No, that was back enough.

73
00:03:16,029 --> 00:03:19,449
Yeah, there was no, it was Pearl and Bash and I was like, that's it. That's for me.

74
00:03:19,490 --> 00:03:23,690
I remember when Pearl Five came out and we were all very excited.

75
00:03:24,160 --> 00:03:25,869
And the best part is even though I didn't want to do C,

76
00:03:25,880 --> 00:03:28,759
I still had to do C because I downloaded software and to make it compiled,

77
00:03:28,770 --> 00:03:29,750
you'd have to fix it.

78
00:03:30,270 --> 00:03:30,850
That's right.

79
00:03:31,089 --> 00:03:33,289
All right. So I want to kind of explain

80
00:03:33,429 --> 00:03:37,529
why this, this memo from the NSA even exists

81
00:03:38,240 --> 00:03:39,050
because,

82
00:03:39,619 --> 00:03:41,479
and I'm going to focus on C specifically,

83
00:03:41,490 --> 00:03:47,119
I know they say C and C++ and there's other memory managed languages and whatever

84
00:03:47,130 --> 00:03:50,460
we're just gonna talk about C because I like it and I want to,

85
00:03:50,690 --> 00:03:54,220
well, and by like by lines of code and by volume and by impact,

86
00:03:54,660 --> 00:03:55,779
this is like talking about rope,

87
00:03:56,300 --> 00:03:57,460
it's, you know. Yeah.

88
00:03:58,520 --> 00:04:00,139
Yeah. Totally. Totally. OK.

89
00:04:00,300 --> 00:04:05,039
So what does it mean that you have to do your own memory management in C? Right?

90
00:04:05,050 --> 00:04:07,820
When we think of programming, like let's say we're doing Python.

91
00:04:08,110 --> 00:04:11,110
If we have a string, we just have a string and we can

92
00:04:11,289 --> 00:04:14,380
append stuff to it, we can manipulate it,

93
00:04:14,389 --> 00:04:16,420
we can do whatever and we don't think twice about it.

94
00:04:16,428 --> 00:04:16,790
Like

95
00:04:16,988 --> 00:04:20,709
-- you take two strings, you stick them together, pop it
-- out of the stack, bend it,

96
00:04:20,720 --> 00:04:21,500
insert it.

97
00:04:21,820 --> 00:04:24,440
Yeah. And you don't have to think about like how big is it? What's it going into?

98
00:04:24,450 --> 00:04:28,429
-- Do I need a N, do I need an extra bite for the null terminating
-- bite? Right.

99
00:04:28,440 --> 00:04:30,609
And, and we don't even null terminating.

100
00:04:30,779 --> 00:04:34,290
I don't even know like that's not even a topic in Python, right?

101
00:04:34,299 --> 00:04:37,109
So what happens in, in the world of C

102
00:04:37,429 --> 00:04:40,679
if you want to say, put a string in a variable,

103
00:04:41,130 --> 00:04:44,320
you have to first allocate memory to hold the string

104
00:04:44,829 --> 00:04:46,799
and you have to allocate the correct amount of memory.

105
00:04:46,809 --> 00:04:47,459
And as Kurt said,

106
00:04:47,470 --> 00:04:50,029
there's a thing called like a null terminator on many

107
00:04:50,040 --> 00:04:52,739
data structures which is just a null byte of zero

108
00:04:52,890 --> 00:04:53,809
but not all,

109
00:04:54,549 --> 00:04:55,089
not all

110
00:04:55,220 --> 00:04:57,260
I know. And that, I mean, that's part of the challenge, right?

111
00:04:57,269 --> 00:05:00,339
Well, I think a big problem is there's a, there's no consistency,

112
00:05:01,279 --> 00:05:02,950
right? Because if it was consistent,

113
00:05:03,230 --> 00:05:04,980
consistently inconsistent, it's fine.

114
00:05:06,500 --> 00:05:08,450
OK. So we've got our,

115
00:05:08,769 --> 00:05:11,029
our, our bit of memory, we have to allocate

116
00:05:11,130 --> 00:05:12,190
and then we do things to it.

117
00:05:12,200 --> 00:05:14,500
And so let's say you have, I'm just gonna pick on strings a lot.

118
00:05:14,510 --> 00:05:16,010
So I think they're easy to understand.

119
00:05:16,200 --> 00:05:17,109
You have a string

120
00:05:17,500 --> 00:05:18,170
and

121
00:05:18,529 --> 00:05:21,329
you, you wanna add some characters to the string,

122
00:05:21,609 --> 00:05:22,859
you can't just add them.

123
00:05:22,869 --> 00:05:24,820
If you allocated the correct amount of memory,

124
00:05:24,829 --> 00:05:26,750
you have to know how much memory you allocated,

125
00:05:26,760 --> 00:05:30,059
which could be the amount of memory needed for the string.

126
00:05:30,070 --> 00:05:34,269
Exactly. It could be more because sometimes you just allocate extra

127
00:05:34,369 --> 00:05:35,100
for fun.

128
00:05:35,239 --> 00:05:36,140
You know, knowing

129
00:05:36,369 --> 00:05:38,029
you're pulling it out of a database, you're like, hey,

130
00:05:38,320 --> 00:05:43,410
this table is, you know, a 1024 character field. So let's allocate 1024 characters

131
00:05:45,459 --> 00:05:46,140
and then you do some reds

132
00:05:46,489 --> 00:05:47,100
on that string.

133
00:05:48,690 --> 00:05:49,450
Oh my goodness. Red

134
00:05:49,579 --> 00:05:49,609
jack

135
00:05:49,799 --> 00:05:51,190
is like the worst in sea.

136
00:05:51,440 --> 00:05:55,260
But, but anyway, you've got your memory if you want to add something to it.

137
00:05:55,269 --> 00:05:58,799
Now you have to do, it's called reallocate, which is where you say, OK.

138
00:05:58,859 --> 00:06:04,299
Uh This memory is 10 bytes wide. I need 20 bites, right? Like give me 20 bites.

139
00:06:04,309 --> 00:06:07,899
And then the compiler might hand you back the same memory address.

140
00:06:07,910 --> 00:06:09,799
It might hand you a different memory address.

141
00:06:09,809 --> 00:06:11,980
Like you have no idea, not the compiler, the system,

142
00:06:12,140 --> 00:06:12,500
the cur

143
00:06:12,890 --> 00:06:15,200
you have no idea what you're going to get back.

144
00:06:15,209 --> 00:06:18,299
And so obviously, that's part of how it works. You do your stuff

145
00:06:18,600 --> 00:06:20,619
and then you have to free it at the end because if

146
00:06:20,630 --> 00:06:23,220
you have a long running application and you don't free the memory,

147
00:06:23,459 --> 00:06:23,989
now,

148
00:06:24,000 --> 00:06:28,010
you essentially will fill up all the memory space and the application will crash.

149
00:06:28,260 --> 00:06:30,540
And so it's this kind of allocate,

150
00:06:30,679 --> 00:06:33,299
use reallocate and free.

151
00:06:33,720 --> 00:06:38,299
And to be clear, this is what actually the correct term memory leak is.

152
00:06:38,309 --> 00:06:41,369
And a lot of people use memory leaks is like memory being disclosed.

153
00:06:41,589 --> 00:06:43,600
But according to CWE and everything else,

154
00:06:43,609 --> 00:06:46,779
a memory leak is where you basically use memory and fail to free it afterwards.

155
00:06:46,790 --> 00:06:47,859
And also fun fact,

156
00:06:47,989 --> 00:06:51,220
it's not just adding to strings where you have to potentially reallocate stuff.

157
00:06:51,299 --> 00:06:54,390
But for example, when you remove stuff from a string, you can actually

158
00:06:54,790 --> 00:06:58,119
things can still go wrong and that's you can have under reads,

159
00:06:58,130 --> 00:07:01,640
-- you can have like there's yeah,
-- that's super corner case,

160
00:07:01,899 --> 00:07:06,079
right. But the point is even even removing stuff from a string can be unsafe.

161
00:07:06,700 --> 00:07:08,079
Strings are basically

162
00:07:08,690 --> 00:07:09,970
anything to do with

163
00:07:10,149 --> 00:07:12,380
any sort of data handling and memory

164
00:07:12,730 --> 00:07:14,600
consequent memory handling and see

165
00:07:14,739 --> 00:07:15,089
is put

166
00:07:15,200 --> 00:07:15,940
potentially dangerous.

167
00:07:15,950 --> 00:07:18,829
There's like literally nothing you can do safely and be like, no, this is fine,

168
00:07:18,839 --> 00:07:19,500
this is safe.

169
00:07:19,510 --> 00:07:21,369
Like literally everything can go wrong.

170
00:07:21,640 --> 00:07:23,540
Right. Right. Because even reading, yes.

171
00:07:23,549 --> 00:07:27,100
And now like, so here's an example, let's say I've got my string

172
00:07:27,269 --> 00:07:29,730
and I forget to put the null terminating character on the app

173
00:07:29,869 --> 00:07:30,679
the zero.

174
00:07:30,950 --> 00:07:35,820
And now I go to read the string will all of the string manipulating functions.

175
00:07:36,160 --> 00:07:37,970
They expect a null terminator.

176
00:07:37,980 --> 00:07:39,570
So what they actually do is they will

177
00:07:39,579 --> 00:07:42,290
read memory until they hit that null terminator.

178
00:07:42,350 --> 00:07:45,390
So they'll read over the end of your string buffer.

179
00:07:45,399 --> 00:07:48,980
See and like why the hell does the compiler and the system allow that?

180
00:07:48,989 --> 00:07:49,869
Like, you know what I mean? That

181
00:07:49,970 --> 00:07:50,769
-- makes
-- because it,

182
00:07:50,779 --> 00:07:54,690
it has no idea how to figure this out because that's

183
00:07:54,700 --> 00:07:57,730
just how C I mean C is a step above assembly,

184
00:07:58,109 --> 00:08:00,059
right? When you're writing assembly code,

185
00:08:00,339 --> 00:08:02,309
there is no concept of anything.

186
00:08:02,320 --> 00:08:06,700
There's a string terminator is an artificial construct that we had to

187
00:08:06,709 --> 00:08:10,019
create just as a way to know when the string was over.

188
00:08:10,309 --> 00:08:13,100
Because there's no, when, when you're dealing with assembler,

189
00:08:13,510 --> 00:08:18,140
you're just literally reading and writing to random locations and memory, right?

190
00:08:18,149 --> 00:08:20,059
And that's fundamentally what C does

191
00:08:20,559 --> 00:08:21,149
remember.

192
00:08:21,160 --> 00:08:23,049
There's all those things writing about how when they had drum

193
00:08:23,059 --> 00:08:25,359
memory and people would write their apps so that it would,

194
00:08:25,989 --> 00:08:29,579
it would sequentially access drum memory because a physically spinning disk with

195
00:08:29,769 --> 00:08:30,859
stuff on it like,

196
00:08:31,260 --> 00:08:36,109
yeah. And they would purposely put things in locations where the head was going to be

197
00:08:36,229 --> 00:08:39,308
when it finished the last operation to make it faster.

198
00:08:39,320 --> 00:08:41,058
And it was, it's complete madness.

199
00:08:41,150 --> 00:08:44,849
I'll look up, there's some funny stories in some of the hacker folklore

200
00:08:45,039 --> 00:08:47,309
that talks about some of this stuff and why like,

201
00:08:47,320 --> 00:08:50,580
like it was very clever programming, but obviously impossible to debug

202
00:08:50,760 --> 00:08:55,200
if you didn't understand exactly what was going on. Like literally on the drum,

203
00:08:55,380 --> 00:08:57,200
you couldn't do anything. It was madness.

204
00:08:57,419 --> 00:08:58,780
Anyway. Anyway,

205
00:08:59,030 --> 00:09:02,070
before we burn all our time talking about strings.

206
00:09:02,219 --> 00:09:06,179
So basically in the world of sea there, it's easy to make these mistakes.

207
00:09:06,190 --> 00:09:10,229
It's easy to like one of my favorites is, let's say you have a string.

208
00:09:10,559 --> 00:09:13,900
Well, let's say you have memory allocate. It doesn't matter what it is, you free it,

209
00:09:14,140 --> 00:09:16,390
right? The idea is when you free it, you tell the the comp

210
00:09:16,590 --> 00:09:17,260
the colonel,

211
00:09:17,750 --> 00:09:20,969
like I'm giving you this memory back, add it back to the pool, right?

212
00:09:21,450 --> 00:09:23,210
But what happens if you free it again?

213
00:09:23,679 --> 00:09:28,010
Because when, when you free memory, it doesn't like clear the memory to zeros,

214
00:09:28,020 --> 00:09:29,400
it leaves whatever was there.

215
00:09:29,409 --> 00:09:30,650
So when you free it again,

216
00:09:30,929 --> 00:09:33,809
now weird things happen in the memory manager

217
00:09:34,039 --> 00:09:38,530
and a double free is actually a, a pretty serious security vulnerability now.

218
00:09:38,539 --> 00:09:40,530
Well, cwe 415.

219
00:09:40,909 --> 00:09:41,809
There you go.

220
00:09:42,599 --> 00:09:44,280
And it was funny because I remember there was

221
00:09:44,289 --> 00:09:47,030
a time we thought double freeze were just crashes

222
00:09:47,179 --> 00:09:50,400
and then solar designer figured out how to exploit it and we're like, well,

223
00:09:50,409 --> 00:09:53,859
crap now we have to deal with this stuff.

224
00:09:54,359 --> 00:09:56,419
Well, and there's also you're forgetting about use after free,

225
00:09:56,429 --> 00:10:00,150
like you free the memory and then another part of your apps like, hey,

226
00:10:00,159 --> 00:10:01,460
I still needed that.

227
00:10:01,599 --> 00:10:03,210
Give, give it to me

228
00:10:03,809 --> 00:10:05,869
and you know, things go sideways

229
00:10:06,179 --> 00:10:06,590
yet again

230
00:10:07,900 --> 00:10:08,179
with that.

231
00:10:08,750 --> 00:10:09,580
I mean, this is

232
00:10:09,750 --> 00:10:10,880
the problem with that.

233
00:10:10,890 --> 00:10:11,479
So let's say you're,

234
00:10:11,489 --> 00:10:14,299
you're using memory and what happens you have these pointers into the memory,

235
00:10:14,309 --> 00:10:14,530
right?

236
00:10:14,539 --> 00:10:17,700
So like different parts of your program can have pointers and be reading

237
00:10:17,710 --> 00:10:20,940
and writing to different parts of memory and what will happen like this

238
00:10:21,184 --> 00:10:24,205
after free. So if one part of it says I'm done with this memory, let's free it.

239
00:10:24,294 --> 00:10:25,965
Another part still thinks you're using it.

240
00:10:26,234 --> 00:10:28,284
So it might still be reading and writing to memory,

241
00:10:28,294 --> 00:10:32,684
which the application is probably going to work just fine for the most part

242
00:10:32,695 --> 00:10:37,205
because in the historic use of C while that memory wasn't technically allocated,

243
00:10:37,215 --> 00:10:38,525
it was still accessible.

244
00:10:38,909 --> 00:10:43,570
But now if another part of the application asks the memory manager, hey,

245
00:10:43,580 --> 00:10:47,289
give me a block of memory and it hands that block of memory.

246
00:10:47,299 --> 00:10:51,049
Now you have two different parts of the application using the same memory

247
00:10:51,250 --> 00:10:52,770
and they're going to potentially trample

248
00:10:52,780 --> 00:10:55,330
on each other and cause unpredictability.

249
00:10:56,190 --> 00:11:00,059
-- And like this is, I'm just scratching the surface and
-- this is why I use Python.

250
00:11:00,479 --> 00:11:00,539
Yeah.

251
00:11:00,669 --> 00:11:01,650
Right. Right. We'll get to that.

252
00:11:03,549 --> 00:11:05,789
And this is, and you have to think like you've got,

253
00:11:05,799 --> 00:11:08,979
if statements you have control flow, there's so much going on

254
00:11:09,270 --> 00:11:11,130
and if you can write to places in memory,

255
00:11:11,140 --> 00:11:14,820
-- you're not supposed to concurrency
-- shared memory Numa.

256
00:11:15,059 --> 00:11:15,859
Right. Right.

257
00:11:17,359 --> 00:11:17,590
Right.

258
00:11:17,599 --> 00:11:19,830
It's like there's so much complexity here and,

259
00:11:19,840 --> 00:11:23,690
and we're just like we're not even that smart and we're just scratching the surface.

260
00:11:23,700 --> 00:11:26,150
You can imagine the insane difficulty.

261
00:11:26,250 --> 00:11:28,549
Did you read that Netflix Tech blog where they just sold

262
00:11:28,880 --> 00:11:29,500
a um

263
00:11:30,059 --> 00:11:31,349
using Java,

264
00:11:31,359 --> 00:11:33,650
they basically scaled from one type of instance to an

265
00:11:33,659 --> 00:11:35,260
instance that should have been about 2 to 3 times,

266
00:11:35,270 --> 00:11:35,820
perform it.

267
00:11:35,830 --> 00:11:37,210
But it wasn't, it was exactly the same.

268
00:11:37,469 --> 00:11:40,830
And what they found out was is that essentially it was a cash miss.

269
00:11:41,150 --> 00:11:42,890
So there was a one in eight chance the cash

270
00:11:42,900 --> 00:11:45,280
would be correct and thus quick and fast and then

271
00:11:45,409 --> 00:11:47,489
check up seven and eight chance the cash,

272
00:11:47,619 --> 00:11:49,770
you know, because it's an eight core system with eight caches

273
00:11:50,400 --> 00:11:52,809
essentially that it would miss and you know,

274
00:11:53,030 --> 00:11:55,229
latency spikes all over the place. And it was crazy

275
00:11:55,390 --> 00:11:58,849
and they literally added a 64 byte padding statement

276
00:11:59,179 --> 00:12:01,179
and all the latencies and everything just poop

277
00:12:01,719 --> 00:12:06,890
and they got something like 350% performance improvement by adding a 64 byte pad.

278
00:12:07,059 --> 00:12:09,169
So that to force the cash

279
00:12:09,659 --> 00:12:12,679
and the CPU to kind of be in alignment and everything to work out, right?

280
00:12:12,690 --> 00:12:14,840
And it literally was like a 10 line code change.

281
00:12:15,640 --> 00:12:16,510
Yeah, it's just,

282
00:12:16,570 --> 00:12:19,929
and that's in Java where like you technically have memory management, but

283
00:12:20,049 --> 00:12:22,419
even if you have memory management, you can still,

284
00:12:22,630 --> 00:12:24,070
you know, stuff gets put in a cache

285
00:12:24,229 --> 00:12:26,200
for a different CPU core and

286
00:12:26,409 --> 00:12:28,880
now the time and latency is all over the place. So,

287
00:12:29,530 --> 00:12:30,890
so one thing to point out is

288
00:12:31,210 --> 00:12:31,679
like

289
00:12:32,270 --> 00:12:33,919
even if you use a memory safe language,

290
00:12:33,940 --> 00:12:35,809
you won't have maybe as many security problems,

291
00:12:35,820 --> 00:12:37,070
but you will still have problems because

292
00:12:37,080 --> 00:12:40,039
just this is an inherently difficult problem,

293
00:12:40,049 --> 00:12:40,380
right?

294
00:12:40,390 --> 00:12:41,969
And, and look, let's be clear,

295
00:12:41,979 --> 00:12:45,969
you can use Python and Python still has security vulnerabilities.

296
00:12:45,979 --> 00:12:50,130
It just doesn't have like buffer overflows. For example,

297
00:12:51,380 --> 00:12:51,440
what's

298
00:12:51,580 --> 00:12:52,190
different,

299
00:12:52,359 --> 00:12:56,119
the kind of vulnerabilities it has typically are solved in Python.

300
00:12:56,130 --> 00:12:58,210
And I don't have to do anything other than upgrade Python

301
00:12:58,760 --> 00:13:00,390
in in some cases,

302
00:13:01,159 --> 00:13:01,590
right?

303
00:13:01,830 --> 00:13:05,900
That's a big part of it is like with C you know, I have to fix all that code.

304
00:13:06,520 --> 00:13:08,030
OK? So let, let's talk about that.

305
00:13:08,039 --> 00:13:10,270
So there's a note in this document from the

306
00:13:10,280 --> 00:13:11,989
NSA which will of course be in the show notes

307
00:13:12,260 --> 00:13:15,020
where they talk about Microsoft and Google.

308
00:13:15,349 --> 00:13:18,969
They, they, if you look at their, they, there was a presentation

309
00:13:19,200 --> 00:13:19,890
Oh, it just says.

310
00:13:19,900 --> 00:13:23,559
So Microsoft revealed at a conference in 2019 that from 2006 to

311
00:13:23,570 --> 00:13:27,409
2018 70% of their vulnerabilities were due to memory safety issues.

312
00:13:27,559 --> 00:13:29,729
And then Google also found a similar percentage

313
00:13:30,039 --> 00:13:31,169
over seven years in chrome.

314
00:13:31,820 --> 00:13:34,000
And and I mean, you have to remember

315
00:13:34,179 --> 00:13:36,320
that when you're dealing with something like chrome or

316
00:13:36,330 --> 00:13:39,979
windows or internet explorer or edge or whatever,

317
00:13:40,070 --> 00:13:45,239
these are applications that are essentially dealing with hostile code.

318
00:13:45,250 --> 00:13:47,820
Well, hostile data, hostile code, everything

319
00:13:48,109 --> 00:13:51,409
and not even intentionally hostile but just broken stuff. Like I've

320
00:13:51,520 --> 00:13:54,679
stumbled across older web servers or web servers that are non conforming.

321
00:13:54,690 --> 00:13:56,369
Or I remember literally, oh,

322
00:13:56,380 --> 00:14:00,599
we had one provider that had an HSTS header that had an extra semicolon.

323
00:14:00,609 --> 00:14:01,580
So technically,

324
00:14:01,590 --> 00:14:03,640
it should be ignored because it was incorrect and

325
00:14:03,650 --> 00:14:06,289
some browsers would ignore it correctly and some actually

326
00:14:06,390 --> 00:14:10,090
listen to it, which is technically incorrect, but much safer,

327
00:14:10,409 --> 00:14:12,479
right? But, but anyway, you get the point. There's,

328
00:14:12,880 --> 00:14:17,450
there's all of the C code that has memory problems and a lot

329
00:14:17,460 --> 00:14:21,919
of the bugs that we find in browsers and operating systems are fundamentally me

330
00:14:22,039 --> 00:14:26,429
-- memory safety issues, especially
-- the exploitable security vulnerabilities

331
00:14:26,940 --> 00:14:27,119
to be the

332
00:14:27,460 --> 00:14:27,489
man

333
00:14:28,000 --> 00:14:33,469
we've added some technologies over the years to try to mitigate some of this.

334
00:14:33,799 --> 00:14:36,780
And they talk about this in this NSA document

335
00:14:36,979 --> 00:14:40,830
where there's things like Microsoft has something called control flow guard,

336
00:14:41,099 --> 00:14:46,159
which is meant to prevent an application from executing unexpected code.

337
00:14:46,169 --> 00:14:47,640
Like one of the things that will happen

338
00:14:48,210 --> 00:14:52,239
if I can write arbitrary things into random places in memory,

339
00:14:52,520 --> 00:14:55,080
I can potentially overwrite a function pointer

340
00:14:55,340 --> 00:14:58,669
or potentially a return address or something like that.

341
00:14:59,099 --> 00:15:02,630
And so control flow guard is supposed to catch some of that. It won't catch it all.

342
00:15:02,640 --> 00:15:03,320
Obviously,

343
00:15:03,520 --> 00:15:08,200
we created address space layout randomization, which is a SLR

344
00:15:08,429 --> 00:15:12,090
the idea behind this is when we used to write exploits. Back in the day,

345
00:15:12,349 --> 00:15:16,090
every compiled application would use the same memory addresses for everything.

346
00:15:16,099 --> 00:15:18,280
So you could say like I know the return address for

347
00:15:18,289 --> 00:15:20,960
this function is going to be at this memory location.

348
00:15:20,969 --> 00:15:24,830
If I can overwrite that memory location, I can take control of the program,

349
00:15:24,840 --> 00:15:25,619
stuff like that.

350
00:15:25,960 --> 00:15:29,140
And so we changed that. So now all of the addresses are random.

351
00:15:29,349 --> 00:15:32,020
Fun fact, this was uh I think it was an IBM consultant,

352
00:15:32,030 --> 00:15:35,969
gave a talk at a Linux users group like this is two de uh about a decade or well,

353
00:15:35,979 --> 00:15:36,960
no two decades ago.

354
00:15:37,239 --> 00:15:40,299
And he said that was one of his favorite reasons for using.

355
00:15:40,340 --> 00:15:40,979
Oh jeez,

356
00:15:40,989 --> 00:15:42,530
was it Gen two Linux where you basically

357
00:15:42,539 --> 00:15:44,494
had compile everything yourself on your system?

358
00:15:44,674 --> 00:15:46,744
Because every gen two system had different

359
00:15:46,895 --> 00:15:49,385
-- return addresses.
-- That's right. That's right.

360
00:15:49,434 --> 00:15:54,525
And, and when, well, usually when you compile something on two different systems,

361
00:15:54,534 --> 00:15:55,424
you get two different

362
00:15:55,674 --> 00:15:59,364
address layouts, you know, not always, but generally speaking, that is true

363
00:15:59,914 --> 00:16:04,085
there is something we created called depth, which is data execution prevention.

364
00:16:04,125 --> 00:16:06,184
One of the favorites from back in the day

365
00:16:06,395 --> 00:16:07,015
is

366
00:16:07,549 --> 00:16:12,700
you could write shell code into like stack memory or heat memory

367
00:16:12,799 --> 00:16:15,330
and then just jump right to it and it would execute.

368
00:16:15,340 --> 00:16:17,659
And so we we eventually we were like wait a minute.

369
00:16:17,979 --> 00:16:20,700
There's no reason we should ever be executing

370
00:16:20,710 --> 00:16:22,419
code from this piece of memory over here.

371
00:16:22,429 --> 00:16:25,020
Like just say, not executable, right? Never execute.

372
00:16:25,030 --> 00:16:27,340
It's only for reading and writing data.

373
00:16:27,479 --> 00:16:30,099
If you want to blame somebody for that, you can blame John Von Newman.

374
00:16:30,619 --> 00:16:31,349
Like literally,

375
00:16:31,359 --> 00:16:34,500
this is how fundamentally architecturally this stuff

376
00:16:34,510 --> 00:16:36,280
goes back in time because there are,

377
00:16:36,469 --> 00:16:38,710
there were sort of theorized but never

378
00:16:38,719 --> 00:16:42,679
really executed computer architectures where data and executable

379
00:16:42,799 --> 00:16:45,200
memory and stuff was separate.

380
00:16:45,950 --> 00:16:46,349
But

381
00:16:46,510 --> 00:16:48,559
I I can't even imagine how you'd build that

382
00:16:48,570 --> 00:16:51,489
system in the in to be modern performing system.

383
00:16:53,099 --> 00:16:53,799
So actually

384
00:16:54,179 --> 00:16:58,250
Itanium did this which has has garnered the name Itanic,

385
00:16:58,659 --> 00:17:01,400
which this was the intel chip from hand

386
00:17:01,539 --> 00:17:03,799
like 2000 give or take.

387
00:17:04,260 --> 00:17:08,569
They they tried to create a different kind of 64 bit processor. It was

388
00:17:08,760 --> 00:17:10,270
pretty banana is what it did.

389
00:17:10,280 --> 00:17:12,290
I I did some research on it way back in the day

390
00:17:12,300 --> 00:17:15,040
because I worked at a little start up called Progeny Linux systems.

391
00:17:15,430 --> 00:17:16,050
And

392
00:17:16,380 --> 00:17:17,670
it was, oh man, it was like,

393
00:17:17,680 --> 00:17:20,329
I think HP maybe sent us a whole bunch of Itanium

394
00:17:20,339 --> 00:17:22,270
to do development because obviously they wanted to sell them,

395
00:17:22,280 --> 00:17:23,569
say looking for developers

396
00:17:23,699 --> 00:17:26,520
who development was 89 to 2000.

397
00:17:27,880 --> 00:17:28,319
Amazing.

398
00:17:28,969 --> 00:17:31,319
It was one of those things where it started like it was kind

399
00:17:31,329 --> 00:17:33,920
of one of those hail Marys to like fundamentally change the world.

400
00:17:33,930 --> 00:17:37,089
And no, I'm sorry man, if it's not X 86 it's not happening.

401
00:17:37,630 --> 00:17:38,979
I mean, and, and that's what happened.

402
00:17:39,010 --> 00:17:39,599
But anyway,

403
00:17:39,609 --> 00:17:44,239
the itanium had a special register stack because one of the things we would

404
00:17:44,250 --> 00:17:48,729
do back in those days is if you could get a stack buffer overflow,

405
00:17:49,030 --> 00:17:53,160
the return address for function calls was just stored on the stack.

406
00:17:53,219 --> 00:17:56,050
And if you could overwrite that, that variable,

407
00:17:56,060 --> 00:17:59,869
you could basically make the application jump to wherever you want your shell code.

408
00:17:59,880 --> 00:18:00,410
Ideally

409
00:18:00,770 --> 00:18:04,270
and Itanium put all the registers somewhere else.

410
00:18:04,329 --> 00:18:08,349
That way you couldn't do that, right. You couldn't access the register stack

411
00:18:08,520 --> 00:18:12,189
when you were in a function call. But we know how that worked out. Anyway,

412
00:18:12,290 --> 00:18:14,109
there, there's also not mention in this,

413
00:18:14,119 --> 00:18:16,390
there's things like stack canaries have been added.

414
00:18:16,459 --> 00:18:17,319
There's

415
00:18:17,530 --> 00:18:22,050
uh uh there, there's uh return oriented programming RP

416
00:18:22,160 --> 00:18:24,010
protections that have been added.

417
00:18:24,020 --> 00:18:27,105
There's, there's all this other technology that was added to C over the,

418
00:18:27,115 --> 00:18:28,336
the countless decades.

419
00:18:28,556 --> 00:18:29,786
And fundamentally, not just

420
00:18:30,286 --> 00:18:33,095
-- but
-- also to the compilers to the operating system.

421
00:18:33,355 --> 00:18:34,686
That's all, it's all compiler stuff.

422
00:18:34,696 --> 00:18:37,355
It's not added to C I shouldn't, I shouldn't clarify that.

423
00:18:37,365 --> 00:18:42,485
Yes, the compilers and operating systems and fundamentally like it's better,

424
00:18:42,495 --> 00:18:43,806
it's harder to exploit.

425
00:18:43,816 --> 00:18:44,526
But it's

426
00:18:44,735 --> 00:18:46,686
like we haven't solved these problems.

427
00:18:46,696 --> 00:18:48,582
This would be like trying to solve the

428
00:18:48,592 --> 00:18:52,781
fundamental problems of cars and humans driving cars by

429
00:18:52,901 --> 00:18:56,141
having humans continue to drive cars. Like we'll somehow make it

430
00:18:56,391 --> 00:18:58,432
like, yeah, we can add airbags, we can add anti lock brakes,

431
00:18:58,442 --> 00:18:59,621
we can make it safer and better.

432
00:18:59,631 --> 00:19:04,062
But with fundamentally, this technology has limitations that just

433
00:19:04,371 --> 00:19:04,962
humans,

434
00:19:05,972 --> 00:19:07,822
that's exactly the right answer. Like

435
00:19:08,151 --> 00:19:11,521
in terms of safety with automobiles, we've probably reached

436
00:19:11,839 --> 00:19:15,739
about the limits of what we can do with humans driving.

437
00:19:15,869 --> 00:19:16,989
Like if you buy a super high

438
00:19:17,099 --> 00:19:18,709
end car now and have a super high

439
00:19:18,839 --> 00:19:19,859
end trained driver,

440
00:19:20,359 --> 00:19:20,729
there's,

441
00:19:21,280 --> 00:19:23,890
are you gonna bet that they'll never have an accident? Would you bet your life? Of

442
00:19:24,130 --> 00:19:25,349
-- course not, of
-- course not.

443
00:19:25,989 --> 00:19:27,500
And it might not be their fault, right?

444
00:19:27,510 --> 00:19:30,140
There's like so much that can happen and same thing with C

445
00:19:30,469 --> 00:19:33,130
and then they also talk about in this, some of the,

446
00:19:33,290 --> 00:19:34,020
there's like

447
00:19:34,339 --> 00:19:37,589
Sat and DAST, which is static analysis and dynamic analysis.

448
00:19:37,599 --> 00:19:41,800
And examples of this are you have like source code analyzers that

449
00:19:41,900 --> 00:19:45,369
these applications will look at your source code and try to find bugs that

450
00:19:45,380 --> 00:19:48,709
-- you might have put in which in
-- C fuzzing that scale like American fuzzy

451
00:19:49,030 --> 00:19:50,280
loop and you know. Right.

452
00:19:50,290 --> 00:19:50,530
Well,

453
00:19:50,540 --> 00:19:53,109
and there's like Os S Fuzz doing this kind of work and that's

454
00:19:53,119 --> 00:19:57,699
like gas where you're running the application and you're dumping garbage into it

455
00:19:58,060 --> 00:20:00,050
and you're trying to crash it

456
00:20:00,489 --> 00:20:04,869
and, and like, those have also helped make things better, but again,

457
00:20:05,270 --> 00:20:07,560
we've kind of reached the limits of what all of

458
00:20:07,569 --> 00:20:10,670
this technology can do in terms of making c better.

459
00:20:10,959 --> 00:20:12,910
And so I think that's why

460
00:20:13,119 --> 00:20:15,739
we're seeing some of this complaining and I think

461
00:20:15,750 --> 00:20:18,229
the more important part of this a decade ago,

462
00:20:18,239 --> 00:20:20,670
if I would have told you, we have to stop using c

463
00:20:21,010 --> 00:20:22,319
people would probably nod their head.

464
00:20:22,560 --> 00:20:24,369
Yeah. Well, we did, we,

465
00:20:24,510 --> 00:20:24,670
well,

466
00:20:24,680 --> 00:20:28,109
it's the same thing saying like a decade ago we have to stop using gasoline cars.

467
00:20:28,439 --> 00:20:28,770
Well,

468
00:20:29,439 --> 00:20:31,119
I agree with you in principle.

469
00:20:31,219 --> 00:20:31,520
But

470
00:20:32,079 --> 00:20:34,719
-- what
-- exactly. And now what was exactly it?

471
00:20:34,880 --> 00:20:39,550
But now I think this is why we're going to see more of this is, I think the,

472
00:20:39,790 --> 00:20:43,300
the technology has caught up with reality finally

473
00:20:43,729 --> 00:20:45,750
and we have not that we didn't have Python or

474
00:20:45,760 --> 00:20:48,699
Java or many of these other languages in the past.

475
00:20:48,709 --> 00:20:52,949
I think the difference now is we have rust

476
00:20:53,270 --> 00:20:59,060
and we have, I, I guess AAA paradigm shift. I just said paradigm shift.

477
00:20:59,069 --> 00:20:59,829
Not ironically,

478
00:21:00,099 --> 00:21:00,489
um,

479
00:21:00,719 --> 00:21:01,270
in the world, did you?

480
00:21:02,599 --> 00:21:05,280
I did, I can feel it. It's, it's in my bones

481
00:21:05,390 --> 00:21:05,880
but

482
00:21:06,300 --> 00:21:06,949
you know what I mean?

483
00:21:06,959 --> 00:21:08,719
Like we're, we're moving a lot of workloads,

484
00:21:08,729 --> 00:21:10,520
we're changing the way we do a lot of things.

485
00:21:10,530 --> 00:21:14,199
And so I think that the purpose of this is, and they don't even talk about rust in this,

486
00:21:14,209 --> 00:21:15,260
this document, right.

487
00:21:15,270 --> 00:21:17,900
Actually, I should, I should do a search. I don't remember seeing Rust.

488
00:21:18,439 --> 00:21:22,579
Uh oh, they do have Rust? No, that's Rust. Rust. Oh, they do.

489
00:21:22,589 --> 00:21:25,000
They do list Rust as one of their languages.

490
00:21:25,189 --> 00:21:26,310
-- I think
-- realistically,

491
00:21:26,319 --> 00:21:29,329
Rust is one of the best options here for the simple reason that

492
00:21:29,479 --> 00:21:32,979
it plays well with existing sea code and that's the thing to remember, right.

493
00:21:33,000 --> 00:21:33,699
We've talked about this one

494
00:21:33,954 --> 00:21:35,785
but like open SSL is a great example.

495
00:21:36,025 --> 00:21:40,334
You will never rip and replace, well, even if you can rip and replace open SSL,

496
00:21:40,344 --> 00:21:40,724
like TV,

497
00:21:40,734 --> 00:21:43,795
vendors just aren't like it needs to be a perfect drop in

498
00:21:43,805 --> 00:21:47,614
replacement where they like literally change two lines in a config file somewhere

499
00:21:47,755 --> 00:21:48,994
and they might do that.

500
00:21:49,604 --> 00:21:50,255
Yeah. Yeah.

501
00:21:50,435 --> 00:21:55,135
Well, there's, there's two ways, OK? There's two ways to look at this problem.

502
00:21:55,479 --> 00:21:56,430
There's the,

503
00:21:56,489 --> 00:22:00,390
we'll say the Linux kernel way where they're going to add the ability

504
00:22:00,400 --> 00:22:05,530
to add Rust code to the Linux kernel with the obvious intent,

505
00:22:05,540 --> 00:22:07,729
even though it's not spoken out loud very often.

506
00:22:07,839 --> 00:22:12,270
The obvious intent is that eventually core functionality is going to

507
00:22:12,280 --> 00:22:15,660
migrate its way into rust because that's a no brainer.

508
00:22:15,863 --> 00:22:17,792
You don't have memory safety issues.

509
00:22:17,993 --> 00:22:23,133
You gain all of the speed benefits and weirdness of sea without the memory problems.

510
00:22:23,142 --> 00:22:23,593
Well,

511
00:22:23,603 --> 00:22:25,412
more to the point using something like rust

512
00:22:25,422 --> 00:22:27,562
means your device driver developer can now focus on

513
00:22:27,572 --> 00:22:29,312
writing a device driver and not writing a

514
00:22:29,322 --> 00:22:31,772
device driver and doing all their memory management,

515
00:22:31,782 --> 00:22:32,233
that's fair.

516
00:22:32,243 --> 00:22:35,912
And memory management in the kernel is extra weird because it's kernel

517
00:22:36,135 --> 00:22:39,656
-- not like what we're used to
-- when you're dealing with network devices.

518
00:22:39,666 --> 00:22:43,456
-- Oh man, like memory management is a next level
-- difficult.

519
00:22:43,605 --> 00:22:48,156
Well, so here's the problem with, with like device drivers in the kernel.

520
00:22:48,166 --> 00:22:50,046
If you have like a network driver,

521
00:22:50,365 --> 00:22:56,015
you the the the goal is to get something off the network and get it to user space,

522
00:22:56,026 --> 00:22:56,395
right?

523
00:22:56,739 --> 00:23:00,410
And that transition from the kernel to user space is weird because

524
00:23:00,420 --> 00:23:03,930
you can't just hand an application like a pointer into kernels frame

525
00:23:05,069 --> 00:23:07,119
or like or here's an Ethernet frame

526
00:23:07,829 --> 00:23:10,170
like no, the application is like what the hell is an Ethernet frame?

527
00:23:10,199 --> 00:23:13,420
Well, ignoring that, I mean, even once you decode everything

528
00:23:13,750 --> 00:23:15,810
like we we we've had bugs that do this

529
00:23:15,819 --> 00:23:19,660
where where a device driver accidentally handed an application,

530
00:23:19,670 --> 00:23:25,180
a writeable handle into kernel memory and you could, you could create a mess,

531
00:23:25,550 --> 00:23:27,540
right? And like this is a problem.

532
00:23:27,719 --> 00:23:28,510
Now

533
00:23:29,000 --> 00:23:31,920
there's the other half of this I think which is where

534
00:23:32,510 --> 00:23:37,510
if you are like drastically changing your application or let's

535
00:23:37,520 --> 00:23:40,569
say you're migrating from one technology to a new technology,

536
00:23:40,579 --> 00:23:43,089
there is no reason to start a new

537
00:23:43,260 --> 00:23:46,310
product or project or service or whatever and

538
00:23:46,319 --> 00:23:48,869
see like use one of these other languages.

539
00:23:48,880 --> 00:23:52,609
It will be, you will develop faster, it might not be as performant,

540
00:23:52,839 --> 00:23:58,209
-- but the benefits drastically outweigh
-- I'm so glad you said that because the,

541
00:23:58,229 --> 00:24:01,780
the performance argument seems to be the most common.

542
00:24:01,790 --> 00:24:04,219
Go to anti security argument

543
00:24:04,459 --> 00:24:05,540
for memory safety.

544
00:24:06,040 --> 00:24:06,160
Oh,

545
00:24:06,310 --> 00:24:06,530
right.

546
00:24:07,060 --> 00:24:09,609
And what's so, and, and let's be clear here.

547
00:24:09,640 --> 00:24:12,989
I am not against performance because for example, there is a real world impact.

548
00:24:13,000 --> 00:24:15,089
Like if you can make certain functions faster,

549
00:24:15,099 --> 00:24:17,130
it actually has an impact on carbon footprint.

550
00:24:17,140 --> 00:24:19,150
Like there's cloud providers now that are starting

551
00:24:19,160 --> 00:24:21,040
to measure the carbon footprint of workloads.

552
00:24:21,109 --> 00:24:24,359
And for the sake of argument, if you make a workload, 50% more efficient,

553
00:24:24,449 --> 00:24:28,050
that can save tons of carbon emissions like that actually matters.

554
00:24:28,060 --> 00:24:28,560
So,

555
00:24:29,000 --> 00:24:31,560
let's assume like that's a good thing. I'm not against that.

556
00:24:31,569 --> 00:24:35,060
But what I will point out is the vast majority of people have workloads

557
00:24:35,540 --> 00:24:39,119
that are not worth optimizing. So a perfect example, the CS A website

558
00:24:39,359 --> 00:24:43,979
like we're not amazon.com, we have a website, we serve quite a few hits actually.

559
00:24:44,130 --> 00:24:45,229
But you know,

560
00:24:45,359 --> 00:24:50,180
I'm not going to make my devs go spend weeks making it 10% more efficient, right?

561
00:24:50,189 --> 00:24:53,520
It's written in rails, not the most performant language.

562
00:24:53,530 --> 00:24:55,489
Well, perfect example, Mastodon right now, right?

563
00:24:55,500 --> 00:24:57,689
People are discovering Mastodon is kind of a pain to scale

564
00:24:57,699 --> 00:24:59,760
because it's written in Ruby on rails and you know,

565
00:24:59,770 --> 00:25:00,869
like uh what was it, Ariadne

566
00:25:01,369 --> 00:25:03,930
was like? Oh, I gave it bigger CP US,

567
00:25:04,140 --> 00:25:06,819
don't do that. Give it more CP US, right?

568
00:25:06,829 --> 00:25:07,260
And I'm like, yeah,

569
00:25:07,270 --> 00:25:11,920
it's Rails app like you just like our scale plan at the CS A is pay Hiroko more money.

570
00:25:11,930 --> 00:25:13,819
I think a lot of people think that the,

571
00:25:14,160 --> 00:25:16,900
so the performance of your application does matter to some degree because

572
00:25:16,910 --> 00:25:19,319
if your website takes like 60 seconds to return a web page.

573
00:25:19,329 --> 00:25:20,119
Yeah, that's no good.

574
00:25:20,489 --> 00:25:24,239
But fundamentally like when you get it down to say half a second or whatever,

575
00:25:24,250 --> 00:25:26,020
unless you're doing like high frequency trading

576
00:25:26,030 --> 00:25:27,760
or your Amazon running on Black Friday,

577
00:25:27,849 --> 00:25:29,319
the vast majority of us,

578
00:25:29,329 --> 00:25:31,589
something like rails or Python running in its pretty

579
00:25:31,599 --> 00:25:33,839
much default state is more than good enough.

580
00:25:34,010 --> 00:25:36,319
I have a great example for what you just described.

581
00:25:36,829 --> 00:25:40,859
There are services where the performance is very important.

582
00:25:40,869 --> 00:25:44,979
Discord has a blog post where they were using some go

583
00:25:45,319 --> 00:25:46,819
to now go is a,

584
00:25:46,829 --> 00:25:49,339
a memory managed language in the kind of way

585
00:25:49,349 --> 00:25:52,300
Python does it where like garbage collection is go's problem

586
00:25:52,560 --> 00:25:56,760
now it whereas in Rust, you have to basically say like I'm done using this thing.

587
00:25:56,770 --> 00:25:59,000
It's just you can't screw anything up when you're doing it.

588
00:25:59,109 --> 00:25:59,689
Now,

589
00:25:59,920 --> 00:26:02,609
wait, Russ doesn't have built in GC like you have to trigger it.

590
00:26:03,040 --> 00:26:04,400
You have to Yeah, you have to do it yourself,

591
00:26:05,089 --> 00:26:05,719
which is,

592
00:26:05,890 --> 00:26:07,579
which is the, that's the key.

593
00:26:07,589 --> 00:26:12,520
So anyway, Discord was using go and there were these spikes every like two minutes,

594
00:26:12,530 --> 00:26:12,650
right?

595
00:26:12,660 --> 00:26:15,589
It was, it was rust doing garbage collection obviously.

596
00:26:15,869 --> 00:26:20,819
And then they rewrote it or not rust it was go, sorry, go doing garbage collection.

597
00:26:20,910 --> 00:26:21,619
Then

598
00:26:21,800 --> 00:26:23,939
they rewrote it in rust

599
00:26:24,089 --> 00:26:28,380
and it was very smooth because now they were controlling as things were being,

600
00:26:28,390 --> 00:26:29,329
you know, allocated and de

601
00:26:29,430 --> 00:26:29,939
allocated.

602
00:26:30,250 --> 00:26:32,949
Yeah, there's a common problem with languages that have a GC sweep.

603
00:26:32,959 --> 00:26:35,109
You hit that GC sweep and like system latency,

604
00:26:35,880 --> 00:26:36,349
like,

605
00:26:36,719 --> 00:26:36,890
and

606
00:26:37,479 --> 00:26:40,290
there are applications where that is a huge problem.

607
00:26:40,300 --> 00:26:42,670
And like in the case of discord, it was a huge problem.

608
00:26:42,680 --> 00:26:46,670
This is why we now have languages that are capable of dealing with this,

609
00:26:46,680 --> 00:26:48,270
that we didn't have a decade ago.

610
00:26:48,349 --> 00:26:50,790
And so that's why I think like the time is right

611
00:26:50,864 --> 00:26:53,685
to have this discussion and why the NSA is starting it.

612
00:26:53,775 --> 00:26:55,324
Part of it is not just

613
00:26:55,885 --> 00:26:57,505
it's a technology ecosystem, right?

614
00:26:57,515 --> 00:27:00,285
So I don't know if you remember, but I had a slide deck when I worked at Red Hat,

615
00:27:00,295 --> 00:27:03,155
like in the first month I worked there talking about why this cloud happen now.

616
00:27:03,224 --> 00:27:07,045
And it's kind of like rocketry. We had all the ideas for rocketry back in the day,

617
00:27:07,155 --> 00:27:09,265
but we didn't have the metallurgy to

618
00:27:09,275 --> 00:27:11,364
make stuff that could withstand the temperatures

619
00:27:11,640 --> 00:27:16,199
or the idea of like cryo pumps or the idea of like run the fuel around,

620
00:27:16,390 --> 00:27:20,050
you know, the bell nozzle to pre heat it and cool the nozzle. And you know,

621
00:27:20,229 --> 00:27:21,380
the whole thing from exploding.

622
00:27:21,630 --> 00:27:22,959
And this is kind of where we are with

623
00:27:22,969 --> 00:27:27,260
these memory managed safe languages is we also now have

624
00:27:27,640 --> 00:27:28,199
mon,

625
00:27:28,310 --> 00:27:32,780
like my desktop is a Ryzen 5 5600 X. It is a monster CPU

626
00:27:33,030 --> 00:27:34,219
by any standard,

627
00:27:34,489 --> 00:27:38,459
you know, with 48 gigs of ra M. Like, it's just my cheap little windows desktop,

628
00:27:38,939 --> 00:27:39,479
you know,

629
00:27:39,589 --> 00:27:41,359
like your, your

630
00:27:41,530 --> 00:27:45,760
apple ecosystem with the M two chips. Those things are monsters

631
00:27:46,089 --> 00:27:47,069
computationally.

632
00:27:47,209 --> 00:27:48,660
And so part of it is,

633
00:27:48,969 --> 00:27:53,400
it's this whole ecosystem like, like you could build the best Python ever.

634
00:27:53,410 --> 00:27:55,630
But if you're stuck on P one hundreds, it doesn't matter.

635
00:27:55,640 --> 00:27:56,829
It's going to be so terrible,

636
00:27:57,030 --> 00:28:00,449
you know, and also you don't have the frameworks the,

637
00:28:00,459 --> 00:28:02,310
the other bits because like no offense.

638
00:28:02,319 --> 00:28:02,630
But

639
00:28:02,780 --> 00:28:04,869
if you're using just Python, you're doing it wrong.

640
00:28:04,880 --> 00:28:06,890
You want to be using the whole Python pi pie

641
00:28:06,900 --> 00:28:09,410
world because like literally every time I write Python,

642
00:28:09,420 --> 00:28:10,359
I'm like, oh, I have to,

643
00:28:10,579 --> 00:28:14,790
oh I had to write code to like par C pe S. No, I don't import C pe,

644
00:28:15,180 --> 00:28:16,890
right? And that's part of it is.

645
00:28:16,949 --> 00:28:19,579
And this is part of where Rust and especially Python are

646
00:28:19,589 --> 00:28:21,650
starting to take off is that and go is a good,

647
00:28:21,660 --> 00:28:24,319
a great example of this is those standard libraries of like,

648
00:28:24,949 --> 00:28:27,260
OK, people can't go write their own web service anymore.

649
00:28:27,270 --> 00:28:29,790
Just no, you cannot do that, you have to import it.

650
00:28:30,290 --> 00:28:31,270
And this is getting,

651
00:28:31,380 --> 00:28:31,890
you know,

652
00:28:32,060 --> 00:28:32,810
all the,

653
00:28:33,010 --> 00:28:36,969
all the difficult things are being put into libraries by experts.

654
00:28:37,180 --> 00:28:37,609
And

655
00:28:38,030 --> 00:28:40,599
that's part of the power of this is, that's part of it.

656
00:28:40,609 --> 00:28:43,420
You know, when we talked about, like, the open source, can we shut the door?

657
00:28:43,430 --> 00:28:46,160
No, because you're already in the open source world and you can't go write your own.

658
00:28:47,099 --> 00:28:51,089
You know, there's no way to stop. And that's part of this is like, if I give you Rust

659
00:28:51,439 --> 00:28:52,609
and no web server,

660
00:28:53,349 --> 00:28:55,430
well, that's like 90% of people can't use it.

661
00:28:56,339 --> 00:28:57,150
Right. You know what I mean?

662
00:28:57,160 --> 00:29:02,010
Like you need these libraries, you need these extra things like, oh,

663
00:29:02,020 --> 00:29:05,729
it has safe string and like, yeah, I don't care, I need a web server that just works.

664
00:29:05,739 --> 00:29:06,089
I need

665
00:29:06,189 --> 00:29:07,800
all these other things that just work.

666
00:29:08,160 --> 00:29:13,275
-- So
-- you, you raise a good point. So back in the early days when I would write a lot of C

667
00:29:13,395 --> 00:29:14,005
like I,

668
00:29:14,185 --> 00:29:19,165
one of my favorite stories is I was at uh progeny Linux systems and I had to,

669
00:29:19,175 --> 00:29:21,805
I had to decode XML with C because

670
00:29:22,484 --> 00:29:23,114
it was

671
00:29:23,454 --> 00:29:24,244
holy cow.

672
00:29:24,255 --> 00:29:26,444
That was the first job they gave me there because they were like,

673
00:29:26,454 --> 00:29:27,444
we can't figure this out.

674
00:29:27,454 --> 00:29:28,464
Can you figure it out?

675
00:29:29,420 --> 00:29:32,369
They had a memory leak and, and yeah, that was the problem

676
00:29:32,609 --> 00:29:34,089
when people look at XML and

677
00:29:34,329 --> 00:29:36,459
JSON decoders, there are XML and

678
00:29:36,680 --> 00:29:39,650
JSON decoders and there are stream decoders and people,

679
00:29:39,660 --> 00:29:42,050
most people don't know what a stream decoder is because they've

680
00:29:42,060 --> 00:29:44,329
never been on a system slow enough to need it.

681
00:29:44,339 --> 00:29:48,589
We, we needed that. It had to be a stream decoder because we were looking for certain,

682
00:29:48,719 --> 00:29:51,930
yeah, we, we were, it was, it was uh an application run.

683
00:29:52,260 --> 00:29:55,619
It was called Discover Discover Two where it was meant to

684
00:29:55,630 --> 00:29:59,900
do uh uh hardware identification during install of the Linux system.

685
00:30:00,099 --> 00:30:00,640
And we did,

686
00:30:00,650 --> 00:30:02,489
we didn't know we didn't have a lot of memory to work

687
00:30:02,500 --> 00:30:05,180
with because you could potentially have a system with very little memory.

688
00:30:05,189 --> 00:30:08,579
So we purposely had to make it stream and be very memory efficient.

689
00:30:08,589 --> 00:30:10,939
But that also led to memory leaks

690
00:30:11,239 --> 00:30:12,150
because

691
00:30:12,329 --> 00:30:14,640
we were parsing XML. But anyway, anyway,

692
00:30:14,810 --> 00:30:15,239
but,

693
00:30:15,640 --> 00:30:17,630
oh my goodness. Anyway, anyway,

694
00:30:17,760 --> 00:30:18,780
so I, I wanna,

695
00:30:18,790 --> 00:30:20,579
I wanna tie this one up now and I know we've

696
00:30:20,589 --> 00:30:22,819
done a lot of complaining about C because why not?

697
00:30:22,829 --> 00:30:23,819
-- And, and I still
-- love it.

698
00:30:23,829 --> 00:30:27,209
Well, the thing is C was an advancement for the time, but that was 20 well,

699
00:30:27,219 --> 00:30:29,140
30 years ago, it's time to move on

700
00:30:29,430 --> 00:30:29,449
our

701
00:30:29,699 --> 00:30:32,380
-- tools and,
-- and, and I think that's part of it, right?

702
00:30:32,390 --> 00:30:32,540
So,

703
00:30:32,550 --> 00:30:35,969
like I remember in the early days we'd write C and the first thing you did was

704
00:30:35,979 --> 00:30:39,849
you had to sit down and add a whole bunch of functionality for like allocating and de

705
00:30:39,969 --> 00:30:42,280
allocating memory and doing some stuff like that. Like

706
00:30:42,619 --> 00:30:45,520
no developer wants to do that. That's a waste of their time, right?

707
00:30:45,530 --> 00:30:47,959
And these other languages don't necessarily have that.

708
00:30:48,280 --> 00:30:53,079
And I think that's kind of the point of all this, the NSA puts out this, this guidance

709
00:30:53,300 --> 00:30:56,969
-- and fundamentally at the end of the day, it's just stop using C like
-- that's it.

710
00:30:57,369 --> 00:31:00,050
And what's interesting is there are some now anecdotal data points.

711
00:31:00,060 --> 00:31:02,780
So NVIDIA has a slash shot posting that will put the notes.

712
00:31:02,930 --> 00:31:03,630
But uh

713
00:31:04,209 --> 00:31:07,560
but uh here we go back in 2008, a proof of concept exercise was conducted,

714
00:31:07,569 --> 00:31:10,420
two low level security sensitive applications were converted from C to

715
00:31:10,780 --> 00:31:12,660
Spark is this language? I don't know.

716
00:31:13,979 --> 00:31:17,000
So OK, I actually didn't know what spark was. I looked it up.

717
00:31:17,010 --> 00:31:22,290
Spark is a version of ADA that is verified. And in the world of computer science,

718
00:31:22,439 --> 00:31:25,780
if you can verify a language is where you mathematically

719
00:31:25,790 --> 00:31:29,579
prove the program is correct and doesn't contain issues.

720
00:31:29,780 --> 00:31:32,560
There's been a lot of computer science work done in this space,

721
00:31:32,569 --> 00:31:35,119
but generally speaking, it's never caught on because it's,

722
00:31:35,560 --> 00:31:40,459
it's a little too wonky, we'll say. And I mean, wonky in the Wonkish regard,

723
00:31:40,599 --> 00:31:42,869
I actually had a friend who did his phd in this.

724
00:31:42,880 --> 00:31:45,500
But, but getting back to this and that's one of the things they talk about is

725
00:31:45,829 --> 00:31:49,390
rather than having this sort of strategy of security through testing

726
00:31:49,400 --> 00:31:53,170
and sort of hardening is a security strategy of well correctness,

727
00:31:53,180 --> 00:31:54,349
which is interesting because like, for example,

728
00:31:54,359 --> 00:31:56,359
that's what open BS D has always tried to do.

729
00:31:56,369 --> 00:31:57,170
And to claim is like,

730
00:31:57,290 --> 00:31:58,189
they don't care about

731
00:31:58,449 --> 00:31:59,569
security vulnerabilities,

732
00:31:59,579 --> 00:32:03,160
they care about correctness and everything needs to be as correct as possible.

733
00:32:03,369 --> 00:32:05,939
And, you know, and based on the fact that they're using C, well,

734
00:32:05,949 --> 00:32:09,459
there's still vulnerabilities in open SSH two decades later and they've been,

735
00:32:09,469 --> 00:32:11,469
you know, they've been trying to clean that thing up forever.

736
00:32:11,479 --> 00:32:11,949
So that's

737
00:32:12,160 --> 00:32:12,500
the,

738
00:32:12,609 --> 00:32:13,760
the first like,

739
00:32:14,010 --> 00:32:17,060
what's interesting though is um uh here we go as a

740
00:32:17,069 --> 00:32:19,540
result of the proof of concept validated the initial strategy,

741
00:32:19,550 --> 00:32:21,469
the use of spark spread rapidly within NVIDIA.

742
00:32:21,489 --> 00:32:24,609
There are now over 50 developers trained in numerous components implemented

743
00:32:24,619 --> 00:32:27,540
in spark and many NVIDIA products are now shipping with spark components

744
00:32:27,770 --> 00:32:29,010
so it can be done.

745
00:32:29,020 --> 00:32:29,609
But it does,

746
00:32:29,619 --> 00:32:32,319
I think the biggest problem is it requires like a

747
00:32:32,329 --> 00:32:35,270
culture shift because this isn't just a technology change.

748
00:32:35,280 --> 00:32:37,030
This is like going from like I think

749
00:32:37,142 --> 00:32:37,743
before

750
00:32:37,932 --> 00:32:40,743
we started recording the show was or maybe it was on the show,

751
00:32:40,873 --> 00:32:44,483
-- the the whole rocks to bronze transition like that requires
-- just, yeah,

752
00:32:44,493 --> 00:32:45,922
we talked about that at the beginning.

753
00:32:46,012 --> 00:32:46,583
That's just

754
00:32:46,723 --> 00:32:50,922
requires a very fundamental mental shift that not all companies can do

755
00:32:51,172 --> 00:32:55,243
well and not just that if someone like you and I show up to corporate leadership,

756
00:32:55,253 --> 00:32:58,123
we're like we should stop using C and we should the other languages,

757
00:32:58,133 --> 00:32:59,753
-- they're gonna be like, yeah,
-- can security?

758
00:32:59,762 --> 00:33:01,296
Can you have a escorted out? Right?

759
00:33:01,306 --> 00:33:01,546
Where,

760
00:33:01,556 --> 00:33:05,436
where the the people standing on the box preaching to the masses on the corner?

761
00:33:05,446 --> 00:33:07,086
Who don't, don't care what I'm talking about,

762
00:33:07,306 --> 00:33:07,745
right?

763
00:33:07,755 --> 00:33:10,635
Whereas when the NSA and some of these other will say,

764
00:33:10,645 --> 00:33:13,536
large security minded organizations start talking about this.

765
00:33:13,546 --> 00:33:16,635
Now, I'm not just the sole voice of, of sanity.

766
00:33:16,975 --> 00:33:18,215
Now, I can say, look,

767
00:33:18,225 --> 00:33:21,666
these other smart people are saying the same things I've been saying

768
00:33:21,786 --> 00:33:23,336
it's time to listen.

769
00:33:23,550 --> 00:33:26,530
And so I'm hopeful that is what comes of this.

770
00:33:26,750 --> 00:33:29,489
Well, part of it is just acknowledging that there's a problem because I,

771
00:33:29,500 --> 00:33:31,540
I think a lot of people don't think there's a

772
00:33:31,550 --> 00:33:33,530
problem because they've been living with this for so long.

773
00:33:33,540 --> 00:33:37,140
It's just like cars crash, that's normal. What do you mean? Cars shouldn't crash?

774
00:33:37,150 --> 00:33:38,589
Like what they do crash?

775
00:33:38,900 --> 00:33:42,530
You, what are you saying? We should make cars that don't crash? Why, why would we do?

776
00:33:42,540 --> 00:33:43,170
Like, what?

777
00:33:43,459 --> 00:33:44,239
You know, and it's just,

778
00:33:44,250 --> 00:33:46,030
there's so many things in life we live with that

779
00:33:46,040 --> 00:33:48,290
are painful until somebody kind of makes it go away.

780
00:33:48,300 --> 00:33:48,770
We're like,

781
00:33:49,069 --> 00:33:51,579
like, wow, we lived with this horrible thing forever.

782
00:33:51,699 --> 00:33:52,449
That was dumb.

783
00:33:52,729 --> 00:33:53,030
Yeah,

784
00:33:53,130 --> 00:33:57,839
I think we're at the point where, where people don't ask that question anymore.

785
00:33:57,849 --> 00:34:02,160
I think everyone gets, we need to move on. And I think, I mean, this is

786
00:34:02,560 --> 00:34:05,900
I'm hopeful in a couple of years.

787
00:34:06,180 --> 00:34:08,500
Well, and then the next thing is how do we move on?

788
00:34:08,659 --> 00:34:10,139
And we have an answer for that now.

789
00:34:10,320 --> 00:34:10,989
Well, yeah, we do.

790
00:34:11,530 --> 00:34:12,478
And it's not perfect.

791
00:34:12,489 --> 00:34:14,719
I'm not saying like you can just, yeah, just go start writing with,

792
00:34:14,958 --> 00:34:17,840
but we're at the point where it's actually realistically possible and

793
00:34:18,000 --> 00:34:20,750
within, I'm guessing less than five years,

794
00:34:21,239 --> 00:34:23,908
like the Rust standard library and, you know, the,

795
00:34:23,918 --> 00:34:26,069
the training around it and the books around it and everything,

796
00:34:26,079 --> 00:34:27,789
the ecosystem will have caught up enough

797
00:34:28,069 --> 00:34:30,178
that you can actually take a junior Dev and get them

798
00:34:30,188 --> 00:34:32,228
up to speed and rust in probably 3 to 6 months.

799
00:34:32,529 --> 00:34:34,148
I hope so. I truly hope so.

800
00:34:34,158 --> 00:34:37,279
All right, we're gonna find out we'll come back in five years and report back.

801
00:34:37,289 --> 00:34:39,339
All right. Thank you, Kurt. Thank everyone for listening. Go to open

802
00:34:39,458 --> 00:34:42,618
our security podcast.com. Hit up the show, not Susie Pound Os S podcast.

803
00:34:42,628 --> 00:34:45,849
Hashtag on social media. Kurt have a marvelous rest of your day.

804
00:34:46,138 --> 00:34:49,228
You too. Thanks everybody. Thanks, everyone. Bye bye

805
00:34:53,860 --> 00:34:53,918
the.